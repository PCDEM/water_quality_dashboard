---
title: "PINELLAS COUNTY WATER QUALITY DASHBOARD"
output:
  flexdashboard::flex_dashboard:
    logo: www/logo.png
    social: menu
    source_code: https://github.com/PCDEM/water_quality_dashboard
    includes:
      in_header: "google-analytics.html"
runtime: shiny
css: style.css
resource_files:
- GIS/Waterbody_IDs_(WBIDs).cpg
- GIS/Waterbody_IDs_(WBIDs).dbf
- GIS/Waterbody_IDs_(WBIDs).prj
- GIS/Waterbody_IDs_(WBIDs).sbn
- GIS/Waterbody_IDs_(WBIDs).sbx
- GIS/Waterbody_IDs_(WBIDs).shx
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE)

# Set na.rm = TRUE for mean
mean_n <- purrr::partial(mean, na.rm = TRUE)

# Get functions
source('R/funcs.R')
```

```{r data handling, include=FALSE}

# Import water quality data:
wqIn <- readxl::read_excel("Data/Pinellas_County_Water_Quality_Data_2003_2024.xlsx",
                           guess_max = 50000)
# wqIn <- readxl::read_excel("Data/New_Data.xlsx", 
#                            guess_max = 50000)

# Import FDEP WBID water quality thresholds (some of the WBID names may not exactly
# match FDEP WBID names due to Pinellas County monitoring program specifics. For 
# example, Lake Seminole is FDEP WBID 1618 but is split into 1618_N and 1618_S
# since the north and south lobes of the lake are sampled separately:
wCrit <- readxl::read_excel('Data/WBID_criteria.xlsx', sheet = 'Criteria')

# Calculate means for parameters and keep only surface level data (those are the 
# data used to generate plots in the dashboard):
wqM <- wqIn |>
  # dplyr::filter(Level == 'Surface') |>
  dplyr::mutate(TN = TKN + NOX) |>
  dplyr::group_by(WBID, Date, Segment,Type) |>
  dplyr::summarise(
            DO        = mean_n(`DO%_avg`),
            chl_a     = mean_n(`Chl-a`),
            TN        = mean_n(TN),
            TP        = mean_n(TP),
            TSS       = mean_n(TSS),
            Turbidity = mean_n(Turbidity),
            Secchi    = mean_n(Secchi),
            Temp      = mean_n(Temp_Water_avg),
            Salinity  = mean_n(Salinity_avg),
            Ecoli     = mean_n(E_coli),
            Entero    = mean_n(Enterococci)
            ) |>
  dplyr::ungroup()

# Read in Pinellas WBID shapefile and add site type and status. Make the WBIDs
# around Lakes Seminole and Tarpon non-interactive since they are not sampled
# and to make the Lakes easier to click:
wqShp <- sf::st_read('GIS/Waterbody_IDs_(WBIDs).shp') |>
  dplyr::select(WBID, ID = WATERBODY_) |>
  sf::st_transform("+proj=longlat +ellps=WGS84 +datum=WGS84") |>
  dplyr::mutate(Type = wqM$Type[match(WBID, wqM$WBID)],
         Type = ifelse(is.na(Type), 'NOT SAMPLED', Type),
         Status = ifelse(WBID %in% c('1558C', '1558B', '1709D', '1709F', '1716A',
                                     '1696', '1603B', '1700', '1683', '1530',
                                     '1624A', '1556A'), 'Inactive', 
                         ifelse(Type == 'NOT SAMPLED', 'Not Sampled', 'Active')),
         color = ifelse(Type == 'COASTAL' & Status == 'Active', '#00244c',
                  ifelse(Type == 'COASTAL' & Status == 'Inactive', '#6A5ACD',
                   ifelse(Type == 'LAKE', '#40E0D0', 
                    ifelse(Type %in% c('TIDAL', 'FRESHWATER') & Status == 'Active', '#006400',
                     ifelse(Type %in% c('TIDAL', 'FRESHWATER') & Status == 'Inactive', '#E69F00',
                               'gray60'))))),
         interactive = ifelse(WBID %in% c(1486, '1618A', '1603A'), FALSE, TRUE),
         chla_crit   = wCrit$chla_crit[match(WBID,wCrit$WBID)],
         TN_crit     = wCrit$TN_crit[match(WBID,wCrit$WBID)],
         TP_crit     = wCrit$TP_crit[match(WBID,wCrit$WBID)],
         DO_crit     = wCrit$DO_crit[match(WBID,wCrit$WBID)],
         Ecoli_crit  = wCrit$Ecoli_crit[match(WBID,wCrit$WBID)],
         Entero_crit = wCrit$Entero_crit[match(WBID,wCrit$WBID)])
```

```{r WBID map, include=FALSE}

# Create the base map and set options:
m <- leaflet::leaflet(
  options = leaflet::leafletOptions(
    zoomControl = TRUE, 
    zoomSnap    = 0.1, 
    zoomDelta   = 1)
  ) |>
  leaflet::addTiles(attribution = '') |>
  leaflet::addProviderTiles(
    leaflet::providers$CartoDB.Positron, group = 'CartoDB.Positron'
    ) |>
  leaflet::addProviderTiles(
    leaflet::providers$Esri.WorldImagery, group = 'Esri.WorldImagery'
    ) |>
  leaflet::addProviderTiles(
    leaflet::providers$OpenTopoMap, group = 'OpenTopoMap'
    ) |>
  leaflet::setView(
    lng  = -82.72, 
    lat  = 27.905, 
    zoom = 10.6
    )

# Iterate over each unique waterbody type and add them as separate polygon layers.
# This will allow users to highlight specific different water types:
for (type in unique(wqShp$Type)) {
  m <- m |> leaflet::addPolygons(
    data        = wqShp[wqShp$Type == type & wqShp$interactive == TRUE, ],
    group       = type,  
    weight      = 0.8,
    fillOpacity = 0.3,
    stroke      = TRUE,
    color       = 'black',
    opacity     = 0.7,
    fill        = TRUE,
    fillColor   = ~color,
    label       = ~ID,
    highlightOptions = leaflet::highlightOptions(
      color = 'white', 
      weight = 4,
      opacity = 0.5)
    ) 
  }

# Custom legend for WBID types:
wqLeg <- leg('rect', 6, c('#00244c', '#6A5ACD', '#40E0D0', '#006400', '#E69F00', '#696969'),
             0.5, 20, 20)

# Add other elements to the map:
m <- m |> leaflet::addPolygons(
  data        = wqShp[wqShp$WBID == '1486A', ],
  layerId     = 'shape',
  fillOpacity = 0.17,
  stroke      = TRUE,
  color       = 'green',
  fill        = TRUE,
  fillColor   = ~color,
  label       = ~ID
  ) |> 
  leaflet::addLayersControl(
    position = "topleft",  
    baseGroups = c("CartoDB.Positron", "Esri.WorldImagery", "OpenTopoMap"),
    overlayGroups = c(unique(wqShp$Type)),
    options = leaflet::layersControlOptions(
      collapsed = TRUE)
    ) |> 
  leaflet::addPolygons(
    data             = wqShp[wqShp$interactive == FALSE, ],
    popup            = NULL,
    label            = NULL,
    highlightOptions = NULL,
    weight           = 0.8,
    fillOpacity      = 0.3,
    stroke           = TRUE,
    color            = 'black',
    opacity          = 0.7,
    fill             = TRUE,
    fillColor        = 'gray60',
    options          = leaflet::pathOptions(clickable = FALSE)
    ) |>
  leaflet::addScaleBar(
    position = 'bottomleft'
    ) |>
  leaflegend::addLegendImage(
    images      = wqLeg,
    labels      = c('Coastal-Active', 'Coastal-Inactive', 'Lake', 'Stream-Active', 
                    'Stream-Inactive', 'Not Sampled'),
    labelStyle  = "font-size: 14px;",
    width       = 15,
    height      = 11,
    orientation = 'vertical',
    title = htmltools::tags$div('Site Type',
                                style = 'font-size: 15px; text-align: center;
                                font-weight: bold;'),
    position = 'bottomleft'
    ) 
```

```{r get data and plots, include=FALSE}

# Get data for each WBID based on user click:
getData <- reactive({ 
  if (is.null(input$mapplo_shape_click)){
    strat <- '1486A'
    } else {
      strat <- getStrata(
        spDat = wqShp,
        lat   = input$mapplo_shape_click$lat, 
        lng   = input$mapplo_shape_click$lng
        )
      }
  data <- data.frame(
    dplyr::filter(wqM, WBID == strat) |>
    dplyr::select(
      Date, DO, chl_a, TN, TP, TSS, Turbidity, Secchi, Temp, Salinity, Ecoli, Entero
      )
    )
  return(data)
  })

mapplo <- leaflet::leafletProxy('mapplo') 

# Change the highlighted WBID based on user click:
observeEvent(input$mapplo_shape_click, {
  sName <- getStrata(
    spDat = wqShp,                   
    lat   = input$mapplo_shape_click$lat,
    lng   = input$mapplo_shape_click$lng
    )
  mapplo <- mapplo |>
    leaflet::removeShape('shape') |>
    leaflet::addPolygons(
      data        = dplyr::filter(wqShp, WBID == sName),
      layerId     = 'shape',
      fillOpacity = 0.17,
      stroke      = TRUE,
      color = ifelse(wqShp$Status[wqShp$WBID == sName] == 'Active', 'green', 
               ifelse(wqShp$Status[wqShp$WBID == sName] == 'Inactive', 'red',
                      'gray')), 
      fill      = TRUE,
      fillColor = ~color,
      label     = ~ID
      )
  })

# Get the name of the WBID clicked by the user:
site <- reactive({
  if(is.null(input$mapplo_shape_click)){
    sName <- '1486A'
  } else {
    sName <- getStrata(
      spDat = wqShp,
      lat = input$mapplo_shape_click$lat,
      lng = input$mapplo_shape_click$lng
      )
    }
    return(wqShp$ID[wqShp$WBID == sName])
  })

# Dissolved oxygen plot:
DOplo <- reactive({
  return(plt(
    data = dplyr::select(getData(), Date, DO) |> tidyr::drop_na(), 
    var = 'Dissolved Oxygen \n(% sat)',
    crit = wCrit$DO_crit[wCrit$WBID == wqShp$WBID[wqShp$ID == site()]]
    ))
  })

# Chlorophyll-a plot:
chlplo <- reactive({
  return(plt(
    data = dplyr::select(getData(), Date, chl_a) |> tidyr::drop_na(), 
    var  = 'Chlorophyll-a \n(Âµg/L)',
    crit = wCrit$chla_crit[wCrit$WBID == wqShp$WBID[wqShp$ID == site()]]
    ))
  })

# Total nitrogen plot:
TNplo <- reactive({
  return(plt(
    data =dplyr::select(getData(), Date, TN) |> tidyr::drop_na(), 
    var ='Total Nitrogen \n(mg/L)',
    crit = wCrit$TN_crit[wCrit$WBID == wqShp$WBID[wqShp$ID == site()]]
    ))
  })

# Total phosphorus plot:
TPplo <- reactive({
  return(plt(
    data = dplyr::select(getData(), Date, TP) |> tidyr::drop_na(), 
    var  = 'Total Phosphorus \n(mg/L)',
    crit = wCrit$TP_crit[wCrit$WBID == wqShp$WBID[wqShp$ID == site()]]
    ))
  })

# Total suspended solids plot:
TSSplo <- reactive({
  return(plt(
    data = dplyr::select(getData(), Date, TSS) |> tidyr::drop_na(), 
    var  = 'Total Suspended Solids \n(mg/L)'
    ))
  })

# Turbidity plot:
NTUplo <- reactive({
  return(plt(
    data = dplyr::select(getData(), Date, Turbidity) |> tidyr::drop_na(), 
    var  = 'Turbidity \n(NTU)'
    ))
  })

# Secchi depth plot:
Secplo <- reactive({
  return(plt(
    data = dplyr::select(getData(), Date, Secchi) |> tidyr::drop_na(), 
    var  = 'Secchi Depth \n(m)'
    ))
  })

# Total phosphorus plot:
Tplo <- reactive({
  return(plt(
    data = dplyr::select(getData(), Date, Temp) |> tidyr::drop_na(), 
    var = 'Temperature \n(Â°C)'
    ))
  })

# Salinity plot:
Splo <- reactive({
  return(plt(
    data = dplyr::select(getData(), Date, Salinity) |> tidyr::drop_na(), 
    var  = 'Salinity \n(ppt)'
    ))
  })

# E. coli plot:
eplo <- reactive({
  return(plt(
    data = dplyr::select(getData(), Date, Ecoli) |> tidyr::drop_na(), 
    var  = HTML('<em>E. coli</em> \n(MPN/100mL)'),
    crit = wCrit$Ecoli_crit[wCrit$WBID == wqShp$WBID[wqShp$ID == site()]]
    ))
  })

# Enterococcus plot:
entplo <- reactive({
  return(plt(
    data = dplyr::select(getData(), Date, Entero) |> tidyr::drop_na(), 
    var  = HTML('<em>Enterococci</em> \n(MPN/100mL)'),
    crit = wCrit$Entero_crit[wCrit$WBID == wqShp$WBID[wqShp$ID == site()]]))
  })

# Return watershed info based on clicked WBID:
Sinf <- function(site){
  Sw <- wqShp$WBID[wqShp$ID == site()]
  if (Sw == 1440) anclote(input, 'info')
  if (Sw == 1475) hollin(input, 'info')
  if (Sw == 1474) brooker(input, 'info')
  if (Sw == 1643) church(input, 'info')
  if (Sw == 1574) alligator(input, 'info')
  if (Sw == '1527B') bee(input, 'info')
  if (Sw == '1538A') curlew(input, 'info')
  if (Sw == '1624A') roosevelt(input, 'info')
  if (Sw == '1575A') mullet(input, 'info')
  if (Sw == '1668A') joes(input, 'info')
  if (Sw == '1486A') lt(input, 'info')
  if (Sw == '1618C') cross_bayou(input, 'info')
  if (Sw %in% c(1641,1625)) cross(input, 'info')
  if (Sw %in% c(1508, '1508A')) klosterman(input, 'info')
  if (Sw %in% c(1556, '1556A')) cedar(input, 'info')
  if (Sw %in% c(1569, '1569A')) bishop(input, 'info')
  if (Sw %in% c(1604, '1604B1')) allens(input, 'info')
  if (Sw %in% c(1627, '1627B')) long(input, 'info')
  if (Sw %in% c('1618_N','1618_S')) sa_b(input, 'info',site)
  if (Sw %in% c('1558I','1558H2')) otbN(input, 'info',site)
  if (Sw %in% c('1558H','1558G')) otbS(input, 'info',site)
  if (Sw %in% c('1558F','1661')) rb(input, 'info',site)
  if (Sw %in% c('8045','1528C','1528')) sjs(input, 'info',site)
  if (Sw %in% c(1633,'1633B','1633D','1633E')) mckay(input, 'info')
  if (Sw %in% c('1528A','1694B','1694A','1558N')) bcb(input, 'info',site)
  if (Sw %in% c(1529, 1530, 1550, 1614, 1683, 1696, 1700, '1541B', '1530A',
                '1541C', '1603B', '1603D', '1574A', '1567C', '1662A', '1618D',
                '1668B', '1668D', '1558C', '1558B', '1709D', '1709F', '1716A'))
    tbd(input, 'info')
  if (Sw == 'Not Sampled') noInfo(input, 'info')
  }


```

Overview
===========================================================

## Column {.tabset .tabset-fade data-width=650}

```{r screen size modal}
# Initialize a reactive value to track if a water quality subtab has been clicked yet:
fc <- reactiveVal(TRUE)

# UI for the initial informational popup:
screen_txt <- modalDialog(
  title = "MOBILE DEVICE DETECTED",
  HTML("<b>PLEASE NOTE:</b>"),
  tags$p(""),
  HTML("It appears you are attempting to view this dashboard using a mobile device.
       This dashboard is still in development and some features may not be displayed 
       properly on a mobile device. For the best experience, please view this dashboard on a
       desktop or tablet computer."),
  easyClose = TRUE,
  footer = modalButton("Close"),
  style = "font-size:90%"
)

# Make sure initial info popup only displayed when the water quality tab is first 
# opened:
observeEvent(input$active_tab, {
  if (input$active_tab == "Overview" & input$screen_width < 800 & fc()){
    showModal(screen_txt)
    fc(FALSE) 
    }
  })
```


<div class = "row">
<div class = "col-md-2"></div>
<div class = "col-md-8">


#### WELCOME TO THE PINELLAS COUNTY WATER QUALITY DASHBOARD!

```{r, echo = FALSE, out.width = '100%', fig.align = 'center', fig.alt='Image of Fort De Soto Park with coastline'}
knitr::include_graphics('www/banner.png')
```

#### Who We Are and What We Do
The Pinellas County Division of Environmental Management (PCDEM), part of the Pinellas County Public Works Department, is committed to safeguarding environmental health through data collection and application of sound scientific principles. The Division achieves water resource goals by conducting routine water monitoring throughout the county and the surrounding coastal waters. Water samples are collected to determine chemical, physical, and biological elements of streams, lakes, and marine waters within unincorporated Pinellas County and in partnership with various municipalities. Habitat and aquatic species surveys are done at specific times of the year to monitor macroinvertebrates, phytoplankton (including red tide), and benthic and seagrass indicators. Visit our [website](https://pinellas.gov/programs/water-quality-monitoring-program/){target="_blank"} to learn more about our various habitat monitoring programs.

#### Why Water Quality Matters
Water quality is more than just a scientific measure; it's a reflection of the health of our entire ecosystem. Clean water is a home for wildlife and a playground for us â the land and water within the landscape, or watershed, is where we live, work, and play. However, sometimes, water can have too much of certain substances like nutrients, sediment, and bacteria. While nutrients are necessary for aquatic life, in excess, they can be detrimental and lead to overgrowth of algae, resulting in reduced oxygen throughout the waterbody. The process of nutrient enrichment, known as eutrophication, can harm fish and other aquatic organisms as well as block sunlight from reaching aquatic vegetation, including seagrass, and can impair their growth. Healthy seagrass and other aquatic vegetation is important for maintaining healthy levels of dissolved oxygen and providing habitat and food for many marine animal species.

#### Our Success Story â Tampa Bay
Tampa Bay continues to be recognized for water quality and habitat restoration efforts because of collaboration between government entities, academic research, and local stakeholder involvement. Over the last four decades, there has been a concerted effort to improve the bay's water quality through monitoring and adaptive management strategies. Although managing these environmental resources is a continual effort, the success of nutrient reduction in the bay is a testament to what can be achieved through persistent and coordinated environmental management.

#### This Dashboard
This dashboard is designed to make the Divisionâs (PCDEM) monitoring results accessible and summarize how the lakes, streams, and coastal waters measure up compared to past conditions and based on regulatory and management targets. Click on the "Water Quality" to start exploring the water quality data from sites throughout Pinellas County. 


This dashboard provides several types of data for exploration, including:

1) [__Water Quality__](#water-quality): Water quality data from monitoring sites throughout Pinellas County.
1) [__Red Tide & Bacteria__](#red-tide-bacteria): Current Pinellas County red tide and beach bacteria data.
1) [__Annual Report__](#annual-report): Annual report summarizing water quality and habitat monitoring data
1) [__Data Downloads__](#data-download): Downloadable water quality data.

<br>

The source content for this dashboard can be viewed on [Github](https://github.com/PCDEM/water_quality_dashboard){target="_blank"}.

Technical questions about our water quality data can be sent to [Stacey Day](mailto:sday@pinellas.gov). 
<br>
Questions and comments about the dashboard can be sent to [Alex Manos](mailto:almanos@pinellas.gov).

<br/><br/>

```{r, echo = FALSE, out.width = '60%', fig.align = 'center', fig.alt='County staff collecting data',fig.cap='Pinellas County staff conducting various types of environmental monitoring activities.'}
knitr::include_graphics('www/collage.png')
```

</div>
<div class = "col-md-2"></div>
</div>


Water Quality 
===========================================================

## Column {.tabset .tabset-fade data-width="280"}

```{r water quality modal}
# Initialize a reactive value to track if a water quality subtab has been clicked yet:
firstClick <- reactiveVal(TRUE)

# UI for the initial informational popup:
txt <- modalDialog(
  title = "NAVIGATING THE WATER QUALITY DATA PAGE",
  HTML("<b>Getting started:</b>"),
  tags$p(""),
  tags$li("Click 'MAP' to view our sampled watersheds."),
  tags$p(""),
  tags$li("Click 'USING THIS TAB' for tab function guidance."),
  tags$p(""),
  tags$li("Click 'BACKGROUND' for general information."),
  br(),
  HTML("<b>Viewing the data:</b>"),
  tags$p(""),
  tags$li("Click any of the colored shapes (watersheds) to view plots and status."),
  tags$p(""),
  tags$li("Click the label at the top of the map for information about the watershed."),
  tags$p(""),
  tags$li("The plots are interactive; use the cursor to highlight data points."),
  tags$p(""),
  tags$li("Click through the tabs to view different water quality parameters."),
  easyClose = TRUE,
  footer = modalButton("Close"),
  style = "font-size:90%"
)

# Make sure initial info popup only displayed when the water quality tab is first 
# opened:
observeEvent(input$active_tab, {
  if (input$active_tab == "Water Quality" & firstClick()){
    showModal(txt)
    firstClick(FALSE) 
    }
  })
```


### MAP

```{r}

# Get water quality map:
output$mapplo <- leaflet::renderLeaflet(m)

# Create a UI element for the WBID info button:
output$info <- renderUI({
  tags$div(id="info-btn-container",
           actionButton("info", 
                        label = HTML(paste0("<i class='fas fa-info-circle'></i> ", 
                                            site())),
                        style = paste0('font-size:', input$screen_width/115, 'px'), 
                        class = "btn"))
})

# Display the map and info button:
fillCol(flex = c(NA, 1, 1),
        uiOutput('info'),
        leaflet::leafletOutput('mapplo'))

# Change watershed info button name:
observeEvent(input$info, {
  Sinf(site())
})

# UI for the initial informational popup:
nsModal <- modalDialog(
  title = "NOTICE",
  HTML("<b>Pinellas County stopped water quality sampling in this area in 2012. For more recent data please contact the City of St. Petersburg Public Works at waterdept@stpete.org.</b>"),
  easyClose = TRUE,
  footer = modalButton("Close")
)

# Display a special message for WBIDs in St. Petersburg:
observeEvent(input$mapplo_shape_click, {
  if (site() %in% c('SMACKS BAYOU', 'TAMPA BAY (UPPER SEGMENT)', 'TAMPA BAY (MIDDLE SEGMENT)',
                    'BOOKER CREEK', 'COFFEEPOT BAYOU', '34TH STREET BASIN',
                    'FRENCHMANS CREEK - BASIN U', 'BAYOU CREEK')) {
    showModal(nsModal)
  }
})

```


### USING THIS TAB

#### Overview
This tab shows water quality data located around Pinellas
County, encompassing both marine and freshwater habitats. The PCDEM
utilizes two methods for water quality sampling: fixed sites for streams and
stratified random sampling for lakes and coastal waterways.

<br> 

#### Navigating the Map
Use the cursor to hover over the sites on the Map tab and click to view water
quality data for that site. Refer to the legend on the bottom left of the map which
denotes both the type of water body and the status of monitoring activity within 
that area. There are coastal, lake, stream, and sites which are not sampled, of which may be inactive (previous monitoring conducted, but none currently) or have never been sampled by PCDEM.

<br>
```{r, fig.align = 'center', out.width = '30%', fig.alt='Map legend'}
knitr::include_graphics('www/legend.png')
```
<br>

Click the informational button at the top right of the map to view more information
about the selected site. 

<br>

#### Viewing the Data
To view the data, click the site of interest and the graphs to the right will
display historical data for the site, if available. There are several tabs that
display different types of water quality data. The panel to the far right displays
a gauge for the threshold criteria used by the Florida Department of Environmental
Protection (FDEP) for water quality standards. The gauge is color-coded to show
the status of the water quality for the selected parameter: green is within acceptable
limits and red is exceeding the limit.

The time-series plots are interactive; the cursor can be used to view the date and 
data for each point and highlight different portions of the plot. A
[control menu](https://help.plot.ly/zoom-pan-hover-controls/){target="_blank"} will also
appear when moving the cursor inside the plot area.

<br>
```{r, fig.align = 'center', out.width = '70%', fig.alt='Plot control menu options'}
knitr::include_graphics('www/plotcontrols.PNG')
```
<br>

Use this menu to zoom, pan, and download the plot as a png file.

<br> 

#### Report Card
The Report Card tab displays a "Pass/Fail" classification for selected parameters
at the selected site over the period-of-record data. For more information about 
the specific criteria used or the calculations involved, please visit out Github 
page which can be accessed by clicking the "Source Code" button at the top of the 
dashboard.

<br> 


### BACKGROUND

#### Land-Based Sites

The fixed, land-based sites (green dots on map below) are located in streams, ditches,
canals, and small lakes around the county. The county is divided into 52
watersheds (the land area that drains into a receiving body of water) and these fixed sites are selected in a way to maximize the coverage area for sampling. The shapes on the watershed map are divided into water body identification numbers (WBIDs), as defined by the [Florida Deparment of Environmental Protection (FDEP)](https://floridadep.gov/dear/watershed-assessment-section/content/basin-411-0){target="_blank"}. These WBIDs help scientists and regulators focus management efforts on specific locations based on the impairment of the water body within each WBID boundary. If two or more water quality sites are located within the same WBID, the data from these sites are averaged to represent the water quality for that WBID and is displayed in the graphs. Click the Data Downloads tab to view site-specific data.

<br>
```{r, fig.align = 'center', out.width = '70%', fig.alt = 'Map of Pinellas County with land-based water quality sites'}
knitr::include_graphics('www/lr.png')
```
<br>

#### Coastal Sites

Water quality is also monitored in the coastal waters and lakes (Lakes Tarpon and Seminole) and follow a similar design to the FDEP WBID with the exception of a few sites which combine/divide WBIDs. On the map tab, marine waters are dark blue and the lakes are light blue. The figure below shows the distribution of
these sampling areas (strata). However, sites E6 And E7 (Middle Tampa Bay) are part of the City of St.
Petersburg water quality monitoring program and are not included in the
counties geographic coverage. Similarly water quality data is not collected by PCDEM in any of the streams or lakes in St. Petersburg. Please contact the [City of St. Petersburg](https://www.stpete.org/){target="_blank"} for more information on their water quality monitoring program.


<br>
```{r, fig.align = 'center', out.width = '70%', fig.alt = 'Map of Pinellas County with coastal water quality sites'}
knitr::include_graphics('www/strata.png')
```
<br>

#### Sampling Design

The strata sites (as well as the land sites) are sampled eight times a year (given
adequate conditions). Since the strata sites are selected based on a
[stratified random sampling design](https://www.epa.gov/quality/selecting-sampling-design#str){target="_blank"}, the sites within each stratum are different during
each sampling event. Each stratum is divided into equally sized hexagons
as shown below for stratum W8.

<br>
```{r, fig.align = 'center', out.width = '70%', fig.alt = 'Grid of hexagons showing sampling design'}
knitr::include_graphics('www/hex.jpg')
```
<br>

A computer program is then used to randomly select points within each
hexagon with equal probability provided to each hexagon. For each sampling event, four points are selected throughout the individual stratum and are labeled A, B, C, and D. The data displayed for the stratum on the time-series plots are an average of those four points. Click the "Data Downloads" tab to view site-specific data. For more information on our water quality sampling design, types of data collected, long-term water quality trends, and summary statistics click on the "Annual Report" tab.


## Column {.tabset .tabset-fade data-width="610"}

### Oxygen, Nutrients, & Chlorophyll-a

```{r}

# Display the data for DO, chl_a, TN, and TP
fillCol(flex = c(1, rep(1, 4)),
        pltmsg(getData, "DO", DOplo),
        pltmsg(getData, "chl_a", chlplo),
        pltmsg(getData, "TN", TNplo),
        pltmsg(getData, "TP", TPplo))

```

### Water Clarity

```{r}

# Display the data for TSS, turbidity, and Secchi. Secchi not collected on stream 
# sites, only lakes and coastal water:
fillCol(flex = c(1, rep(1, 3)),
    pltmsg(getData, "TSS", TSSplo),
    pltmsg(getData, "Turbidity", NTUplo),
    pltmsg(getData, "Secchi", Secplo))

```

### Temperature & Salinity

```{r}

# Display the data for temperature and salinity:
fillCol(flex = c(1, rep(1, 3)),
    pltmsg(getData, "Temp", Tplo),
    pltmsg(getData, "Salinity", Splo))

```

### Bacteria

```{r}

# Bacteria samples only collected in freshwater and tidal stream sites:
fillCol(flex = c(1, rep(1, 2)),
    pltmsg(getData, "Ecoli", eplo),
    pltmsg(getData, "Entero", entplo))

```

### Report Card

```{r}

# Create slider input to narrow down the report card:
sliderInput('year', 'Select year range', 
            min   = 2003, 
            max   = lubridate::year(Sys.Date()) - 1,
            value = c(2003, lubridate::year(Sys.Date()) - 1), 
            step  = 1, 
            sep   = "",
            width = '95%')

# Update the slider with the years available at each site:
observe({
    updateSliderInput(
      session, 'year', 
      min = min(lubridate::year(getData()$Date)),
      max = ifelse(max(lubridate::year(getData()$Date)) == lubridate::year(Sys.Date()),
                   max(lubridate::year(getData()$Date)) - 1,
                   max(lubridate::year(getData()$Date))),
      value = c(min(lubridate::year(getData()$Date)),
                ifelse(max(lubridate::year(getData()$Date)) == lubridate::year(Sys.Date()),
                       max(lubridate::year(getData()$Date))-1,
                       max(lubridate::year(getData()$Date))))
      )
  })

# WBID specific pass/fail summary:
rcd <- reactive({

  # Select the data used for the report card:
  rd <- data.frame(
    wqIn |>
      dplyr::filter(WBID == wqShp$WBID[wqShp$ID == site()]) |>
      dplyr::select(Date, WBID, Type, chl_a = `Chl-a`, chla_q = `Chla_q`,
                    DOsat = `DO%_avg`, DOsat_q = `DO%_q`, TKN, TKN_q, NOX, NOX_q, 
                    TP, TP_q, E_coli, Eco_q, Enterococci, EC_q)) |>
    dplyr::group_by(Date, WBID, Type) |>
    dplyr::summarise_if(is.numeric, mean, na.rm = TRUE)

    # Remove data if it has certain qualifiers associated with it:
    for(i in seq(3, ncol(rd) - 1, 2)){
      rd[, i][which(grepl('J|Y|\\?|\\*\\*', rd[, i + 1]) == TRUE)] <- NA
    }

  # Calculate the 10% exceedance criteria for DO:
  do <- data.frame(
    rd |>
      dplyr::group_by(Year = lubridate::year(Date), Type) |>
      dplyr::filter(Year != lubridate::year(Sys.Date())) |>
      dplyr::summarise(
        total_samples = dplyr::n(),
        n_below = ifelse(Type == 'Coastal', length(which(DOsat < 42)),
                         length(which(DOsat < 38)))) |>
      dplyr::distinct() |>
      dplyr::mutate(do_grade = ifelse((n_below/total_samples) > 0.1, 'Fail', 'Pass'))
    )

  # Calculate the geometric mean exceedence for chl-a, TP, TN, E.coli, and Enterococci
  # and compare to WBID specific FDEP criteria for pass/fail:
  nubact <- data.frame(
    rd |>
      dplyr::mutate(TN = TKN + NOX) |>
      dplyr::select(Date, WBID, Type, chl_a, TP, TN, E_coli, Enterococci) |>
      dplyr::group_by(Year = lubridate::year(Date), WBID, Type) |>
      dplyr::summarise(dplyr::across(c(chl_a, TP, TN, E_coli, Enterococci), \(.)
                                     psych::geometric.mean(., na.rm = TRUE))) |>
      # dplyr::summarise(if(wqShp$WBID[wqShp$ID == site()] %in% c('1558I','1558H','1558H2','1558G','1558F',
      #                                      1661,'1528A','1558N','1694A','1694B','1618C'))
      #   dplyr::across(chl_a),mean,na.rm=TRUE) |>
      dplyr::mutate(
        chl_grade    = ifelse(chl_a >= wCrit$chla_crit[wCrit$WBID == WBID], 'Fail', 'Pass'),
        tp_grade     = ifelse(TP >= wCrit$TP_crit[wCrit$WBID == WBID],'Fail','Pass'),
        tn_grade     = ifelse(TN >= wCrit$TN_crit[wCrit$WBID == WBID],'Fail','Pass'),
        ecoli_grade  = ifelse(E_coli >= wCrit$Ecoli_crit[wCrit$WBID == WBID],'Fail','Pass'),
        entero_grade = ifelse(Enterococci >= wCrit$Entero_crit[wCrit$WBID == WBID],'Fail','Pass')) |>
      dplyr::filter(Year != lubridate::year(Sys.Date()))
    )

  # Combine the DO and nutrient exceedence data:
  rc <- dplyr::bind_cols(do, nubact) |>
    dplyr::select(Year = 'Year...1', `Chlorophyll-a` = chl_grade, 
                  `Dissolved Oxygen` = do_grade, `Total Phosphorus` = tp_grade,
                  `Total Nitrogen` = tn_grade, `E. coli` = ecoli_grade,
                  Enterococci = entero_grade) |>
    dplyr::select_if(~!all(is.na(.))) |>
    dplyr::mutate(across(everything(), ~replace(., is.na(.), ''))) |>
    dplyr::filter(Year >= input$year[1] & Year <= input$year[2])
  
  # Title for WBID-specific report card table:
  title <- paste('Water Quality Report Card for', stringr::str_to_title(site()), 
                 'Watershed')

  # Create the table:
  plotly::plot_ly(
    type   = 'table',
    header = list(
      values = names(rc),
      line   = list(color = 'white'),
      fill   = list(color = '#BCBCBC'),
      align  = 'center',
      font   = list(color = 'white', size = 11),
      height = 20,
      width  = 25),
    cells  = list(
      values = rbind(rc$Year, rc$`Chlorophyll-a`, rc$`Dissolved Oxygen`, 
                     rc$`Total Phosphorus`, rc$`Total Nitrogen`, rc$`E. coli`,
                     rc$Enterococci),
      line = list(color = 'black'),
      fill = list(color = rbind(
        rep('white', length(rc$Year)),
        ifelse(rc$`Chlorophyll-a` == "Pass", "#c6e0b4", 
         ifelse(rc$`Chlorophyll-a` == "Fail", "#f4b084", "white")),
        ifelse(rc$`Dissolved Oxygen` == "Pass", "#c6e0b4", 
         ifelse(rc$`Dissolved Oxygen` == "Fail", "#f4b084", "white")),
        ifelse(rc$`Total Phosphorus` == "Pass", "#c6e0b4", 
         ifelse(rc$`Total Phosphorus` == "Fail", "#f4b084", "white")),
        ifelse(rc$`Total Nitrogen` == "Pass", "#c6e0b4", 
         ifelse(rc$`Total Nitrogen` == "Fail", "#f4b084", "white")),
        ifelse(rc$`E. coli` == "Pass", "#c6e0b4", 
         ifelse(rc$`E. coli` == "Fail", "#f4b084", "white")),
        ifelse(rc$Enterococci == "Pass", "#c6e0b4", 
         ifelse(rc$Enterococci == "Fail", "#f4b084", "white")))),
      align  = 'center',
      font   = list(color = 'black', size = 11),
      height = 21)) |>
    plotly::layout(
      title = list(text = title,
                   font = list(size = 120 / sqrt(nchar(title))),
                   y = 0.985)
      )
  })

 # display table
 fillCol(flex = 1,
         plotly::renderPlotly(rcd()))
 
```


## Column {.tabset .tabset-fade data-width="230"}

### Most Recent Data

```{r}

# JavaScript to get name of active tab:
tags$script("
$(document).on('shown.bs.tab', 'a[data-toggle=\"tab\"]', function (e) {
  Shiny.setInputValue('active_tab', $(e.target).text());
});
")

# Get screen size
tags$script("
  $(document).on('shiny:connected', function() {
    var screenWidth = $(window).width();
    Shiny.onInputChange('screen_width', screenWidth);
  });

  $(window).resize(function() {
    var screenWidth = $(window).width();
    Shiny.onInputChange('screen_width', screenWidth);
  });
")

# Gauge plot colors:
cls = c('green','yellow','red')

# Gauge plot for DO displays most recent value:
output$DOg <- highcharter::renderHighchart({
  gauge(
    data  = dplyr::select(getData(), Date, DO),
    var   = 'Dissolved Oxygen',
    unit  = '%',
    max   = 100, 
    round = 1,
    g1    = wCrit$DO_crit[wCrit$WBID == wqShp$WBID[wqShp$ID == site()]],
    g2    = 100,
    r1    = 0,
    r2    = wCrit$DO_crit[wCrit$WBID == wqShp$WBID[wqShp$ID == site()]],
    width = input$screen_width
    )
  })  

# Gauge plot for Chl-a displays most recent value:
output$chlg <- highcharter::renderHighchart({
  gauge(
    data  = dplyr::select(getData(), Date, chl_a), 
    var   = 'Chlorophyll-a',
    unit  = ' Âµg/L',
    max   = 40,
    round = 1,
    g1    = 0,
    g2    = wCrit$chla_crit[wCrit$WBID == wqShp$WBID[wqShp$ID == site()]],
    r1    = wCrit$chla_crit[wCrit$WBID == wqShp$WBID[wqShp$ID == site()]],
    r2    = 40,
    width = input$screen_width
    )
  })

# Gauge plot for TN displays most recent value:
output$TNg <- highcharter::renderHighchart({
  gauge(
    data  = dplyr::select(getData(), Date, TN), 
    var   = 'Total Nitrogen',
    unit  = ' mg/L',
    max   = 3,
    round = 2, 
    g1    = 0,
    g2    = wCrit$TN_crit[wCrit$WBID == wqShp$WBID[wqShp$ID == site()]],
    r1    = wCrit$TN_crit[wCrit$WBID == wqShp$WBID[wqShp$ID == site()]],
    r2    = 3,
    width = input$screen_width
    )
  })

# Gauge plot for TP displays most recent value:
output$TPg <- highcharter::renderHighchart({
  gauge(
    data  = dplyr::select(getData(), Date, TP), 
    var   = 'Total Phosphorus',
    unit  = ' mg/L',
    max   = 0.6,
    round = 2, 
    g1    = 0,
    g2    = wCrit$TP_crit[wCrit$WBID == wqShp$WBID[wqShp$ID == site()]],
    r1    = wCrit$TP_crit[wCrit$WBID == wqShp$WBID[wqShp$ID == site()]],
    r2    = 1,
    width = input$screen_width
    )
  })

# Gauge plot for TSS displays most recent value:
output$TSSg <- highcharter::renderHighchart({
  gauge(
    data  = dplyr::select(getData(), Date, TSS), 
    var   = 'Total Suspended Solids',
    unit  = ' mg/L',
    max   = 16,
    round = 2, 
    g1    = 0,
    g2    = 16,
    r1    = 0,
    r2    = 0,
    width = input$screen_width
    )
  })

# Gauge plot for turbidity displays most recent value:
output$Turb <- highcharter::renderHighchart({
  gauge(
    data  = dplyr::select(getData(), Date, Turbidity), 
    var   = 'Turbidity',
    unit  = ' NTU',
    max   = 20,
    round = 2, 
    g1    = 0,
    g2    = 20,
    r1    = 0,
    r2    = 0,
    width = input$screen_width
    )
  })

# Gauge plot for secchi displays most recent value:
output$Secg <- highcharter::renderHighchart({
  gauge(
    data  = dplyr::select(getData(), Date, Secchi), 
    var   = 'Secchi Depth',
    unit  = ' m',
    max   = 4,
    round = 2, 
    g1    = 0,
    g2    = 4,
    r1    = 0,
    r2    = 0,
    width = input$screen_width
    )
  })

# Gauge plot for temperature displays most recent value:
output$Tg <- highcharter::renderHighchart({
  gauge(
    data  = dplyr::select(getData(), Date, Temp), 
    var   = 'Temperature',
    unit  = 'Â°C',
    max   = 30,
    round = 2, 
    g1    = 0,
    g2    = 30,
    r1    = 0,
    r2    = 0,
    width = input$screen_width
    )
  })

# Gauge plot for salinity displays most recent value:
output$Sg <- highcharter::renderHighchart({
  gauge(
    data  = dplyr::select(getData(), Date, Salinity), 
    var   = 'Salinity',
    unit  = ' ppt',
    max   = 30,
    round = 2, 
    g1    = 0,
    g2    = 30,
    r1    = 0,
    r2    = 0,
    width = input$screen_width
    )
  })

# Gauge plot for E. coli displays most recent value:
output$eg <- highcharter::renderHighchart({
  gauge(
    data  = dplyr::select(getData(), Date, Ecoli), 
    var   = HTML('<em>E. coli</em>'),
    unit  = ' MPN/100mL',
    max   = 1000,
    round = 0, 
    g1    = 0,
    g2    = wCrit$Ecoli_crit[wCrit$WBID == wqShp$WBID[wqShp$ID == site()]],
    r1    = wCrit$Ecoli_crit[wCrit$WBID == wqShp$WBID[wqShp$ID == site()]],
    r2    = 1000,
    width = input$screen_width
    )
  })

# Gauge plot for Enterococci displays most recent value:
output$entg <- highcharter::renderHighchart({
  gauge(
    data  = dplyr::select(getData(), Date, Entero), 
    var   = HTML('<em>Enterococci</em>'),
    unit  = ' MPN/100mL',
    max   = 1000,
    round = 0, 
    g1    = 0,
    g2    = wCrit$Entero_crit[wCrit$WBID == wqShp$WBID[wqShp$ID == site()]],
    r1    = wCrit$Entero_crit[wCrit$WBID == wqShp$WBID[wqShp$ID == site()]],
    r2    = 1000,
    width = input$screen_width
    )
  })

# Allows for intial gauge render when first navigating to water quality tab from
# overview page:
renderG <- reactiveVal(TRUE)

# Obtain the active tab name from JavaScript code and update the gauge plots:
observeEvent(input$active_tab, {
  if(input$active_tab == 'Oxygen, Nutrients, & Chlorophyll-a' | renderG()) {
    output$gaugePlots <- renderUI({
      fillCol(flex = c(1, rep(1,4)),
        highcharter::highchartOutput("DOg"),
        highcharter::highchartOutput("chlg"),
        highcharter::highchartOutput("TNg"),
        highcharter::highchartOutput("TPg"),
      )
    })
  } else if(input$active_tab == 'Water Clarity') {
    output$gaugePlots <- renderUI({
      fillCol(flex = c(1, rep(1,3)),
        highcharter::highchartOutput("TSSg"),
        highcharter::highchartOutput("Turb"),
        highcharter::highchartOutput("Secg")
      )
    })
  } else if(input$active_tab == 'Temperature & Salinity') {
    output$gaugePlots <- renderUI({
      fillCol(flex = c(1, rep(1,2)),
        highcharter::highchartOutput("Tg"),
        highcharter::highchartOutput("Sg")
      )
    })
  } else if(input$active_tab == 'Bacteria') {
    output$gaugePlots <- renderUI({
      fillCol(flex = c(1, rep(1,2)),
        highcharter::highchartOutput("eg"),
        highcharter::highchartOutput("entg")
      )
    })
  } else if(input$active_tab == 'Report Card'){
    output$gaugePlots <- renderUI({
      fillCol(flex = c(1, rep(1,5)),
        HTML('<em>This tab is under development. The Pass/Fail status for each parameter in a watershed is provisional and needs further verification.</em>'),
          paste('\nThis water quality report card for the',stringr::str_to_title(site()),
                'watershed is based on criteria set by FDEP with a Pass/Fail status for each parameter determined by annual threshold exceedence of 10% of samples (dissolved oxygen) or geometric mean (all other parameters).'),
        paste0(''),
        paste0(''),
        paste0(''))
    })
  } 
  # Need this to allow gauges to update based on clicked tab:
  renderG(FALSE)
})

# Display the gauge plots:
uiOutput("gaugePlots")

```

### FDEP Criteria

Some of FDEP's water quality criteria include dissolved oxygen, chlorophyll-a, and nutrients such as nitrogen and phosphorus, which are important indicators of ecosystem health and whose values can impact one another. 

An increase in nutrient levels in the water can can promote the growth of algal blooms and other nuisance aquatic vegetation. As the blooms begin to die off, their decomposition leads to a decrease in dissolved oxygen in the water, which can be harmful to aquatic life. 

The Pass/Fail designation for each parameter is determined by calculating the annual geometric mean and then comparing it to the FDEP standard. If the value exceeds the FDEP standard, the site will get a 'Fail' for that parameter. If the value does not exceed the standard, the site will get a 'Pass'. Visit the FDEP Water Quality Standards [webpage](https://floridadep.gov/DEAR/Water-Quality-Standards){target="_blank"} for more information about specific water quality criteria throughout the state of Florida.


Red Tide & Bacteria
===========================================================

## Column {.tabset .tabset-fade data-width="180"}

### Red Tide

Red tide is a natural phenomenon in the waters around Pinellas County, caused by an overgrowth of microscopic algae called *Karenia brevis*. These algae produce toxins that can affect marine life and lead to fish kills, as well as cause respiratory irritation in humans, particularly for those with asthma or other respiratory conditions. It often gives the water a reddish or brownish tint, hence the name "red tide."

While red tide blooms can occur year-round, they are most common in Florida around late summer to early fall. The blooms are driven by a combination of warm water temperatures, nutrient availability, and favorable currents. During red tide events, itâs best to limit beach activities, as the airborne toxins can cause eye, nose, and throat irritation. 

<br>
<br>
```{r, fig.align = 'center', out.width = '70%', fig.alt = 'Microscopic image of Karenia brevis'}
knitr::include_graphics('www/k_brevis.png')
```
<br>


### Bacteria

*Enterococcus* is a type of bacteria found in water, soil, and the intestines of humans and animals. This bacterium is used as an indicator of water quality at beaches, as high levels can signal contamination from sources like sewage, stormwater runoff, or animal waste. This contamination can pose health risks, as exposure to *Enterococcus* in water can lead to gastrointestinal illness and a variety of infections.

High levels of *Enterococcus* can be the result of heavy rainfall or stormwater discharge, which can wash contaminants into coastal waters. When *Enterococcus* is elevated, itâs advisable to avoid swimming, particularly for people with open wounds or weakened immune systems. While Pinellas County collects this data to inform the public about water quality issues, the [FL Department of Health](https://www.floridahealth.gov/environmental-health/beach-water-quality/county-detail.html?County=Pinellas&Zip=33701-3109) remains the official source for updates and advisories about beach conditions and water safety.


<br>
```{r, fig.align = 'center', out.width = '50%', fig.alt = 'Microscopic image of Enterococcus'}
knitr::include_graphics('www/entero.png')
```
<br>


```{r}

# Read in red tide and entero data and set limits for color coding:
dat <- readxl::read_excel('Data/Pinellas_RedTide_Entero.xlsx') |>
  dplyr::mutate(`Karenia brevis` = stringr::str_to_title(`Karenia brevis`),
    Color = ifelse(`Karenia brevis` <= 1000, "#878686",
                 ifelse(`Karenia brevis` %in% seq(1001,10000), "white", 
                 ifelse(`Karenia brevis` %in% seq(10001,100000), "yellow",
                 ifelse(`Karenia brevis` %in% seq(100001,1000000), "orange",
                 ifelse(`Karenia brevis` > 1000000, "red", "black"))))),
    bact = ifelse(Enterococcus <= 35, 'green',
           ifelse(Enterococcus >= 36 & Enterococcus <= 70, 'yellow', 'red')),
    Date = format(Date, '%m/%d/%Y'))

```


## Column {.tabset .tabset-fade data-width="310"}

### Red Tide

```{r}

rdate <- dat |>
  dplyr::mutate(Date = as.Date(Date, format('%m/%d/%Y'))) |>
  tidyr::drop_na(`Karenia brevis`) |>
  dplyr::select(Date) |>
  unique()

rd <- seq.Date(rdate$Date[1], rdate$Date[length(rdate$Date)], by = 'day')
rd <- rd[! rd %in% rdate$Date]

# UI for date input and buttons
shinyjs::useShinyjs()  # Enable shinyjs


fluidRow(
  column(12,
         # Wrap the date picker and button in a container
         div(style = "display: inline-block;",
             shinyWidgets::airDatepickerInput(
               inputId = 'rdate',
               label = 'Red Tide Sampling Date',
               minDate = min(rdate$Date),
               maxDate = max(rdate$Date),
               value = max(rdate$Date),
               highlightedDates = rdate$Date,
               disabledDates = rd,
               dateFormat = 'M/d/yyyy',
               autoClose = TRUE,
               width = '85%',
               toggleSelected = FALSE,
               todayButton = TRUE
             )
         ),
         div(style = "display: inline-block; position: relative; top: 15px; margin-left: 60px;",
             actionButton("prev_date1", label = HTML("<i class='fa fa-arrow-left'></i> Previous")),
         ),
         div(style = "display: inline-block; position: relative; top: 15px; margin-left: 60px;",
             actionButton("next_date1", label = HTML("Next <i class='fa fa-arrow-right'></i>")))
  )
)

# Server logic to handle date updates with edge case handling
observe({
  current_date1 <- input$rdate
  
  # Update button states based on the selected date
  if (!is.null(current_date1)) {
    # Disable "Previous" if at the earliest date
    if (current_date1 <= min(rdate$Date)) {
      shinyjs::disable("prev_date1")
    } else {
      shinyjs::enable("prev_date1")
    }
    
    # Disable "Next" if at the latest date
    if (current_date1 >= max(rdate$Date)) {
      shinyjs::disable("next_date1")
    } else {
      shinyjs::enable("next_date1")
    }
  }
})

# Update date picker to the previous date in the dataset. Need to add the plus
# one since the buttons exceed the previous date when published to the website.
# Not sure what the reason is for this.
observeEvent(input$prev_date1, {
  current_date1 <- as.Date(input$rdate)
  prev_date1 <- max(rdate$Date[rdate$Date < current_date1]+1, na.rm = TRUE)
  
  # Check if prev_date is valid before updating
  if (!is.infinite(prev_date1) && !is.na(prev_date1)) {
    shinyWidgets::updateAirDateInput(session, "rdate", value = prev_date1)
  }
})

# Update date picker to the next date in the dataset
observeEvent(input$next_date1, {
  current_date1 <- as.Date(input$rdate)
  next_date1 <- min(rdate$Date[rdate$Date > current_date1]+1, na.rm = TRUE)
  
  # Check if next_date is valid before updating
  if (!is.infinite(next_date1) && !is.na(next_date1)) {
    shinyWidgets::updateAirDateInput(session, "rdate", value = next_date1)
  }
})


# Red tide legend:
rtLeg <- leg('circle', 5, c('#878686', 'white', 'yellow', 'orange', 'red'), 0.8,
             10, 15)


rtm <- reactive({
  
  rDat <- dat |>
    dplyr::mutate(Date = as.Date(Date, format('%m/%d/%Y'))) |>
    dplyr::filter(Date == input$rdate) |>
    tidyr::drop_na(`Karenia brevis`)
  

# Make red tide map
rtm <- leaflet::leaflet(options = leaflet::leafletOptions(zoomControl=FALSE)) |>
  leaflet::addProviderTiles(leaflet::providers$CartoDB.VoyagerLabelsUnder) |>
  leaflet::setView(
    lng  = -82.72, 
    lat  = 27.905, 
    zoom = 10
  ) |>
  leaflet::addCircleMarkers(
    data         = rDat, 
    lng          = ~Longitude, 
    lat          = ~Latitude, 
    color        = 'black',
    radius       = 6, 
    fill         = TRUE,
    fillColor    = ~Color, 
    stroke       = TRUE, 
    weight       = 1.5,
    fillOpacity  = 1,
    label        = ~Site,
    labelOptions = leaflet::labelOptions(
      textsize = "14px"
    ),
    popup = ~paste("<u><b>Red Tide Monitoring</b></u>", "<br>",
                   "Sample Result: ", `Karenia brevis`,"cells/L","<br>",
                   "Location: ", Site, "<br>",
                   "Sample Date: ", Date)
    ) |>
  leaflegend::addLegendImage(
    images      = rtLeg,
    labels      = c('Not Present/Background (0-1,000)', 'Very Low (>1,000-10,000)', 
                    'Low (>10,000-100,000)', 'Medium (>100,000-1,000,000)', 
                    'High (>1,000,000)'),
    labelStyle  = "font-size: 12px;",
    width       = 20,
    height      = 15,
    orientation = 'vertical',
    title = htmltools::tags$div(tags$em('Karenia brevis'),'(cells/L)',
                                style = 'font-size: 15px; text-align: center;
                                font-weight: bold;'),
    position = 'topright'
    ) |>
  leaflet::addScaleBar(
    position = 'bottomleft'
    )
})

rtmap <- leaflet::leafletProxy('rtmap')

output$rtmap <- leaflet::renderLeaflet(rtm())

# Display the red tide map:
fillCol(flex = 0.9,
        leaflet::leafletOutput('rtmap'))

  
```


## Column {.tabset .tabset-fade data-width="310"}

### Bacteria

```{r}

bdate <- dat |>
  dplyr::mutate(Date = as.Date(Date, format('%m/%d/%Y'))) |>
  tidyr::drop_na(Enterococcus) |>
  dplyr::select(Date) |>
  unique()

bd <- seq.Date(bdate$Date[1], bdate$Date[length(bdate$Date)], by = 'day')
bd <- bd[! bd %in% bdate$Date]


# UI for date input and buttons
shinyjs::useShinyjs()  # Enable shinyjs


fluidRow(
  column(12,
         # Wrap the date picker and button in a container
         div(style = "display: inline-block;",
             shinyWidgets::airDatepickerInput(
               inputId = 'bdate', 
               label = 'Bacteria Sampling Date',
               minDate = min(bdate$Date),
               maxDate = max(bdate$Date),
               value = max(bdate$Date),
               highlightedDates = bdate$Date,
               disabledDates = bd,
               dateFormat = 'M/d/yyyy',
               autoClose = TRUE,
               width = '85%',
               toggleSelected = FALSE,
               todayButton = TRUE
             )
         ),
         div(style = "display: inline-block; position: relative; top: 15px; margin-left: 60px;",
             actionButton("prev_date", label = HTML("<i class='fa fa-arrow-left'></i> Previous")),
         ),
         div(style = "display: inline-block; position: relative; top: 15px; margin-left: 60px;",
             actionButton("next_date", label = HTML("Next <i class='fa fa-arrow-right'></i>")))
  )
)


# Server logic to handle date updates with edge case handling
observe({
  current_date <- input$bdate
  
  # Update button states based on the selected date
  if (!is.null(current_date)) {
    # Disable "Previous" if at the earliest date
    if (current_date <= min(bdate$Date)) {
      shinyjs::disable("prev_date")
    } else {
      shinyjs::enable("prev_date")
    }
    
    # Disable "Next" if at the latest date
    if (current_date >= max(bdate$Date)) {
      shinyjs::disable("next_date")
    } else {
      shinyjs::enable("next_date")
    }
  }
})

# Update date picker to the previous date in the dataset
observeEvent(input$prev_date, {
  current_date <- as.Date(input$bdate)
  prev_date <- max(bdate$Date[bdate$Date < current_date]+1, na.rm = TRUE)
  
  # Check if prev_date is valid before updating
  if (!is.infinite(prev_date) && !is.na(prev_date)) {
    shinyWidgets::updateAirDateInput(session, "bdate", value = prev_date)
  }
})

# Update date picker to the next date in the dataset
observeEvent(input$next_date, {
  current_date <- as.Date(input$bdate)
  next_date <- min(bdate$Date[bdate$Date > current_date]+1, na.rm = TRUE)
  
  # Check if next_date is valid before updating
  if (!is.infinite(next_date) && !is.na(next_date)) {
    shinyWidgets::updateAirDateInput(session, "bdate", value = next_date)
  }
})


# Bacteria legend:
bLeg <- leg('circle', 3, c('green','yellow','red'), 0.8, 15, 20)


bm <- reactive({
  
  bDat <- dat |>
    dplyr::mutate(Date = as.Date(Date, format('%m/%d/%Y'))) |>
    dplyr::filter(Date == input$bdate) |>
    tidyr::drop_na(Enterococcus)

# Make bacteria map
bm <- leaflet::leaflet(options = leaflet::leafletOptions(zoomControl=FALSE)) |>
  leaflet::addProviderTiles(leaflet::providers$CartoDB.VoyagerLabelsUnder) |>
  leaflet::setView(
    lng  = -82.72, 
    lat  = 27.905, 
    zoom = 10
  ) |>
  leaflet::addCircleMarkers(
    data         = bDat,
    lng          = ~Longitude,
    lat          = ~Latitude,
    color        = 'black',
    radius       = 6,
    fill         = TRUE,
    fillColor    = ~bact,
    stroke       = TRUE,
    weight       = 1.5,
    fillOpacity  = 1,
    label        = ~Site,
    labelOptions = leaflet::labelOptions(
      textsize = "14px"
    ),
    popup = ~paste("<u><b>Bacteria Monitoring (Enterococcus)</b></u>", "<br>",
                   "Sample Result: ", Enterococcus, "MPN/100mL","<br>",
                   "Location: ", Site, "<br>",
                   "Sample Date: ", Date)
    ) |>
  leaflegend::addLegendImage(
    images      = bLeg,
    labels      = c('Good (<35)','Moderate (36-70)', 'Poor (>70)'),
    labelStyle  = "font-size: 12px;",
    width       = 20,
    height      = 15,
    orientation = 'vertical',
    title = htmltools::tags$div(tags$em('Enterococcus'), '(MPN/100mL)',
                                style = 'font-size: 15px; text-align: center;
                                font-weight: bold;'),
    position = 'topright'
    ) |>
  leaflet::addScaleBar(
    position = 'bottomleft'
    ) 
})

bmap <- leaflet::leafletProxy('bmap')


output$bmap <- leaflet::renderLeaflet(bm())

# Display the bacteria map:
fillCol(flex = 0.9,
        leaflet::leafletOutput('bmap'))

```


Annual Report
===========================================================

## Column {.tabset .tabset-fade data-width="250"}

### BACKGROUND

This report is the most recent annual water quality prepared by the Pinellas County Division of Environmental Managemnet and describes sampling methodology, data trends, water quality summary statistics, and biological monitoring results. For more information about this report or to request previous years' reports, please contact Stacey Day (sday@pinellas.gov).


## Column {.tabset .tabset-fade data-width="640"}

### Annual Water Quality Report

```{r}
# Display a annual report PDF:
fillCol(flex = c(1,0.1),
  tags$iframe(style = "border: none; width: 100%; height: 100%;",
              src = "2022 PCDEM Ambient Water Quality Report.pdf"))
```


Data Download
===========================================================

## Column {.tabset .tabset-fade data-width="280"}

### Water Quality

```{r}

# Get data for download
datWB <- reactive({
  return(dat <- wqIn |>
           dplyr::filter(WBID == wqShp$WBID[wqShp$ID == site()]))
  })

# Create a reactive table:
tab <- reactive({
  dat <- datWB()
    out <- reactable::reactable(
      dat,
      defaultColDef = reactable::colDef(
        footerStyle = list(fontWeight = "bold"),
        format      = reactable::colFormat(digits = 2, separators = FALSE),
        resizable   = TRUE
        ),
      filterable = TRUE,
      defaultPageSize = 50
      )
    return(out)
    })

# Data download:
output$datFull <- downloadHandler(
  filename = function(){'Pinellas_County_Water_Quality_Data_2003_2024.xlsx'},
  content = function(file){
    file.copy('Data/Pinellas_County_Water_Quality_Data_2003_2024.xlsx',file)
  }
)

output$datSel <- downloadHandler(
  filename = function(){paste0('Pinellas_County_',site(),'_Water_Quality_Data.xlsx')},
  content = function(file){
    openxlsx::write.xlsx(datWB(), file)
  }
)

# Data download button:
fillCol(flex = c(0.06,0.05, 1),
  shinyWidgets::downloadBttn('datFull', paste0('Download Period of Record Data (',
                                              round(file.size('Data/Pinellas_County_Water_Quality_Data_2003_2024.xlsx')/(1024^2),1),' Mb)'), 
                             style = 'simple', block = TRUE, color = 'success'),
  shinyWidgets::downloadBttn('datSel', 'Download Selected Site Data', 
                             style = 'simple', block = TRUE, color = 'success'),
  reactable::renderReactable(tab())
  )

```